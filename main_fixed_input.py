from random import choice
from custom_channels import unreliable_channel
from utils import hamm, encode, decode

# Declarar los datos que son enviados
str_input="""10110101101001101100101001
01001011100010011010011101
11100101001100111100110101
00011110110010110110001100
10101010101010101010101010
01101101101101101101101101
10011001100110011001100110
11010011001010011101101001
00110101001110101010010101
01011100110111001011001100
11100011100011100011100011
00001111000011110000111100
10100101101001011010010110
11001100110011001100110011
00110011001100110011001100
11111111111111111111111111
00000000000000000000000000
10000000000000000000000001
01000000000000000000000010
00100000000000000000000100
00010000000000000000001000
00001000000000000000010000
00000100000000000000100000
00000010000000000001000000
00000001000000000010000000
00000000100000000100000000
00000000010000001000000000
00000000001000010000000000
00000000000100100000000000
00000000000011000000000000
11111100000011111100000011
11000011111100000011111100
10101010101010101010101010
01010101010101010101010101
11110000111100001111000011
00001111000011110000111100
10011010010101101001011010
01100101101010010110100101
11001011010010110100101101
00110100101101001011010010
11111111111100000000000000
00000000000011111111111111
10101010101001010101010101
01010101010110101010101010
10000011111100000011111100
01111100000011111100000011
11001111000011110000111100
00111100001111000011110000
10101111000010101111000010"""

# Declarar los datos que son recibidos
str_output="""10010101101001101100101001
00001011100010011010011101
10100101001100111100110101
00011110110010110110001100
10101010101010101010101010
01101101101101101101101101
10011001100110011001100110
11010011001010011101101001
00110101001110101010010101
01011100110111001011001100
11100011100011100011100011
00001111000011110000111100
10100101101001011010010110
11001100110011001100110011
00110011001100110011001100
11111111111111111111111111
00000000000000000000000000
10000000000000100000000001
01000000000000000000000010
00100000000000000000000100
00010000000001000000001000
00001000000000000000010000
00000100000000000000100000
00000010000000000001000000
00000001000000000010000000
00000000100000000100000000
01000000010000001000000000
00000000001000010000000000
00000000000100100000000000
00000010000011000000000000
11111110000011111100000011
11000011111100000011111100
10101010101010101010101010
01010101010101010101010101
11110000111100001111000011
00001111000011110000111100
10011010010101101001011010
01100111101010010110100101
11001011010010110100101101
00110101101101001011010010
11111111111100000000000000
00000001000011111111111111
10101011101001010101010101
01010101110110101010101010
10000011111100000011111100
01111100000011111100000011
11001111000011110000111100
00111100001111000011110001
10101111000010101111000011"""


def parse(str_msg):
    """ Transfoma los mensajes de entrada y de salida (stings) en una lista de listas con cada elemento como 0 o 1. """
    return [[int(b) for b in x] for x in str_msg.split('\n')]


def add_parities(encoded, not_encoded):
    """ Agrega bits de pariedad a una lista no codificada que no los tiene a parir de sus valores en una lsita codificada. """
    not_encoded.insert(0, encoded[0])
    i = 0
    while len(encoded) > len(not_encoded):
        not_encoded.insert(2**i, encoded[2**i])
        i += 1
        

def main(show: bool = False):
    # Mensajes enviados y recibidos formateados apropiadamente
    input = parse(str_input)
    output = parse(str_output)
    
    unreliable = unreliable_channel()                           # Declarar objeto para alterar los mensajes
    terminators = ["Arnold Schwarzenegger", "Robert Patrick"]   # Nombres de los actores de los terminators que corregiran los mensajes
    
    for i in range(len(input)):         # Para cada Mensaje ...
        print(f"\nMENSAJE {i+1}")
        
        # Opcionalmente, imprimir mensaje original
        if show:
            print(f'[Mensaje Original: {input[i]}]\n')
            
        # Codificar mensaje con bits de pariedad y, opcionalmente, mostrarlo
        encoded_msg = encode(input[i])
        if show:
            print(f'[Mensaje codificado: {encoded_msg}]\n')
        
        # Obtener recivido (como copia), añadirle bits de pariedad y, opcionalmente, mostrarlo
        received_msg = output[i].copy()
        add_parities(encoded_msg, received_msg)
        if show:
            print(f'[Mensaje recibido: {received_msg}]\n')
            
        # Utilizar códigos de Hamming para corregir el error y, opcionalmente, mostrar el mensaje corregido
        n = hamm(received_msg)
        if n == 0:
            print("Mensaje recibido perfectamente\n")
        else:
            print(f"Oh no... hay un error el posicion {n} del mensaje codificado. Enviando a {choice(terminators)} al pasado para corregirlo.\n")
            received_msg[n] = (received_msg[n]+1)%2
            print("Mensaje corregido. Gracias por confiar en Cyberdine Systems AC de CV (made in Apodaca)\n")
        if show:
            print(f"[Mensaje Corregido: {received_msg}]\n")
            
        # Quitar bits de pariedad al mensaje y, opcionalmente, mostrarlo
        decoded_msg = decode(encoded_msg)
        if show:
            print(f"[Mensaje decodificado: {decoded_msg}]\n")
    
    
if __name__ == '__main__':
    main()