from random import choice
from custom_channels import unreliable_channel
from utils import hamm, encode, decode

# Declare the data that is going to be sent
str_input="""10110101101001101100101001
01001011100010011010011101
11100101001100111100110101
00011110110010110110001100
10101010101010101010101010
01101101101101101101101101
10011001100110011001100110
11010011001010011101101001
00110101001110101010010101
01011100110111001011001100
11100011100011100011100011
00001111000011110000111100
10100101101001011010010110
11001100110011001100110011
00110011001100110011001100
11111111111111111111111111
00000000000000000000000000
10000000000000000000000001
01000000000000000000000010
00100000000000000000000100
00010000000000000000001000
00001000000000000000010000
00000100000000000000100000
00000010000000000001000000
00000001000000000010000000
00000000100000000100000000
00000000010000001000000000
00000000001000010000000000
00000000000100100000000000
00000000000011000000000000
11111100000011111100000011
11000011111100000011111100
10101010101010101010101010
01010101010101010101010101
11110000111100001111000011
00001111000011110000111100
10011010010101101001011010
01100101101010010110100101
11001011010010110100101101
00110100101101001011010010
11111111111100000000000000
00000000000011111111111111
10101010101001010101010101
01010101010110101010101010
10000011111100000011111100
01111100000011111100000011
11001111000011110000111100
00111100001111000011110000
10101111000010101111000010"""

# Declare the data that are going to be received
str_output="""10010101101001101100101001
00001011100010011010011101
10100101001100111100110101
00011110110010110110001100
10101010101010101010101010
01101101101101101101101101
10011001100110011001100110
11010011001010011101101001
00110101001110101010010101
01011100110111001011001100
11100011100011100011100011
00001111000011110000111100
10100101101001011010010110
11001100110011001100110011
00110011001100110011001100
11111111111111111111111111
00000000000000000000000000
10000000000000100000000001
01000000000000000000000010
00100000000000000000000100
00010000000001000000001000
00001000000000000000010000
00000100000000000000100000
00000010000000000001000000
00000001000000000010000000
00000000100000000100000000
01000000010000001000000000
00000000001000010000000000
00000000000100100000000000
00000010000011000000000000
11111110000011111100000011
11000011111100000011111100
10101010101010101010101010
01010101010101010101010101
11110000111100001111000011
00001111000011110000111100
10011010010101101001011010
01100111101010010110100101
11001011010010110100101101
00110101101101001011010010
11111111111100000000000000
00000001000011111111111111
10101011101001010101010101
01010101110110101010101010
10000011111100000011111100
01111100000011111100000011
11001111000011110000111100
00111100001111000011110001
10101111000010101111000011"""


def parse(str_msg):
    """ Transforms input and output messages (strings) into a list of lists with each element as either 0 or 1. """
    return [[int(b) for b in x] for x in str_msg.split('\n')]


def add_parities(encoded, not_encoded):
    """ Adds parity bits to an unencoded list that does not have them based on their values ​​in an encoded list. """
    not_encoded.insert(0, encoded[0])
    i = 0
    while len(encoded) > len(not_encoded):
        not_encoded.insert(2**i, encoded[2**i])
        i += 1
        

def main(show: bool = False):
    # Messages sent and received formated appropeately
    input = parse(str_input)
    output = parse(str_output)
    
    unreliable = unreliable_channel()                           # Declare objet to simulate sending messages
    terminators = ["Arnold Schwarzenegger", "Robert Patrick"]   # Names of the terminators that can be sent to the past
    
    for i in range(len(input)):         # For each message...
        print(f"\nMENSAJE {i+1}")
        
        # Optionally, print the orignal message
        if show:
            print(f'[Original: {input[i]}]\n')
            
        # Encode the message &, optinally, show it
        encoded_msg = encode(input[i])
        if show:
            print(f'[Encoded: {encoded_msg}]\n')
        
        # Get received messages (as copy), add parity bits and, optionally, show it
        received_msg = output[i].copy()
        add_parities(encoded_msg, received_msg)
        if show:
            print(f'[Received: {received_msg}]\n')
            
        # Use hamming codes to correct the error and, optionally, show the corrected message
        n = hamm(received_msg)
        if n == 0:
            print("Message received perfectl\n")
        else:
            print(f"Oh no... there's an error at positon {n}. Sending {choice(terminators)} to the past to fix it.\n")
            received_msg[n] = (received_msg[n]+1)%2     # Correct Error :)
            print("Error Corrected. Thank you for trusting Cyberdine Systems AC de CV (made in Apodaca)\n")
        if show:
            print(f"[Corrected: {received_msg}]\n")
            
        # Remove parity bits from messate adn, optionally, show it
        decoded_msg = decode(encoded_msg)
        if show:
            print(f"[Decoded: {decoded_msg}]\n")
    
    
if __name__ == '__main__':
    main()